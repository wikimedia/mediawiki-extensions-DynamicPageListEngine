<?php

/**
 * @file
 *
 * @ingroup Extensions
 * @ingroup Extensions-DynamicPageListEngine
 *
 * @author [RV1971](https://www.mediawiki.org/wiki/User:RV1971)
 */

/**
 * Selection by extrax information.
 *
 * Recognizes the parameters `extrax` and `notextrax`. `extrax` selects
 * exact matches of the extrax information appended to the sort key
 * (see documentation of
 * DpleFeatureResults::toTitles()) for the first
 * selected category. `notextrax` select the complement of this. If no
 * categories are selected, the parameters are silently ignored.
 *
 * If `extrax` is an array, the result is
 * (obviously) the union of the record sets satisfying its elements,
 * unlike other parameters (including `notextrax`) where the
 * result is the intersection.
 *
 * @ingroup Extensions
 * @ingroup Extensions-DynamicPageListEngine
 */
class DpleFeatureExtrax extends DpleFeatureBase
implements DpleFeatureInterface {

	/**
	 * Extrax information pages to select should provide with
	 * the category tag for the first category.
	 */
	private $extraxs_;

	/**
	 * Extrax information pages to select should not provide
	 * with the category tag for the first category.
	 */
	private $notExtraxs_;

	/**
	 * @param array $params
	 * @param array &$features
	 */
	public function __construct( array $params, array &$features ) {
		parent::__construct( $features );

		if ( isset( $params['extrax'] ) ) {
			$this->extraxs_ = array_map( [ $this, 'parseText' ],
				(array)$params['extrax'] );
		}

		if ( isset( $params['notextrax'] ) ) {
			$this->notExtraxs_ = array_map( [ $this, 'parseText' ],
				(array)$params['notextrax'] );
		}
	}

	public function getExtraxs() {
		return $this->extraxs_;
	}

	public function getNotExtraxs() {
		return $this->notExtraxs_;
	}

	/**
	 * Get the database cost generated by this feature instance.
	 */
	public function getCost() {
		/** If @ref $extraxs_ is an array, its items are put together
		 *	with OR operators, which is typcially slow, therefore one
		 *	unit of @ref DpleFeature::getCost() is
		 *	accounted for each item. Items in @ref $notExtraxs_ instead
		 *	are put together with AND, which is typically efficient,
		 *	and therefore only one unit is accounted for the whole
		 *	array, if any.
		 */
		return ( count( $this->extraxs_ ) + (int)(bool)$this->notExtraxs_ )
			* parent::getCost();
	}

	/**
	 * Modify a given query.
	 * @see DpleFeatureBase::modifyQuery()
	 *
	 * @param DpleQuery &$query
	 */
	public function modifyQuery( DpleQuery &$query ) {
		$containsFeature = $this->getFeature( 'DpleFeatureContains' );

		/** Do nothing if no contains was defined. */
		if ( !isset( $containsFeature )
			|| !$containsFeature->getLinkedCount() ) {
			return;
		}

		$dbr = $query->getDbr();

		/** Otherwise, also fetch the sort key for the first
		 *	category.
		 */
		$query->addVars( [ 'sortkeyx' => 'clx1.cl_sortkey_prefix' ] );

		if ( $this->extraxs_ ) {
			$extraxConds = [];

			/** Add conditions based on @ref $extraxs_. */
			foreach ( $this->extraxs_ as $extrax ) {
				$extraxConds[] = 'clx1.cl_sortkey_prefix'
					. $dbr->buildLike( $dbr->anyString(), "|$extrax" );
			}

			$query->addConds( '(' . implode( ' OR ', $extraxConds ) . ')' );
		}

		/** Add conditions based on @ref $notExtraxs_. */
		foreach ( (array)$this->notExtraxs_ as $extrax ) {
			$query->addConds( 'clx1.cl_sortkey_prefix NOT '
				. $dbr->buildLike( $dbr->anyString(), "|$extrax" ) );
		}
	}
}
